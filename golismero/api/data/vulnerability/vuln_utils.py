#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Vulnerability ID processing utilities.
"""

__license__ = """
GoLismero 2.0 - The web knife - Copyright (C) 2011-2013

Authors:
  Daniel Garcia Garcia a.k.a cr0hn | cr0hn<@>cr0hn.com
  Mario Vilas | mvilas<@>gmail.com

Golismero project site: https://github.com/golismero
Golismero project mail: golismero.project<@>gmail.com

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""

__all__ = [
    "extract_vuln_ids",
    "convert_references_to_vuln_ids",
    "convert_vuln_ids_to_references",
]

import re

from random import choice
from re import finditer
from string import ascii_letters, digits, printable


#------------------------------------------------------------------------------

# ID extraction from plain text.
_vuln_id_regex = {
    "bid": [
        re.compile(
            r"\b(?:BID\-|BID\: ?|BUGTRAQ\-|BUGTRAQ\: ?|BUGTRAQ ID: ?)"
            r"([0-9]+)\b"),
    ],
    "ca": [
        re.compile(r"\bCA\-([0-9][0-9][0-9][0-9]\-[0-9][0-9])\b"),
    ],
    "capec": [
        re.compile(r"\bCAPEC(?:\-|\: ?)([0-9]+)\b"),
    ],
    "cve": [
        re.compile(
            r"\bCVE\-([0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9][0-9]?)\b"),
    ],
    "cwe": [
        re.compile(r"\bCWE(?:\-|\: ?)([0-9]+)\b"),
    ],
    "osvdb": [
        re.compile(r"\b(?:OSVDB\-|OSVDB\: ?|OSVDB ID\: ?)([0-9]+)\b"),
    ],
    "sa": [
        re.compile(r"\b(?:SECUNIA|SA)(?:\-|\: ?)([0-9]+)\b"),
        re.compile(r"\bSA([0-9]+)\b"),
    ],
    "sectrack": [
        re.compile(r"\b(?:SECTRACK\-|SECTRACK\: ?|SECTRACK ID\: ?)([0-9]+)\b"),
    ],
    "vu": [
        re.compile(r"\bVU[\#\-]([0-9]+)\b"),
    ],
    "xf": [
        re.compile(r"\bXF\: ?[a-z0-9\-]* ?\(([0-9]+)\)(?:[^\w]|$)"),
        re.compile(r"\bXF\-([0-9]+)\b"),
    ],
}

# ID extraction from URLs.
_vuln_ref_regex = {
    "bid": [
        re.compile(
            r"^https?\:\/\/(?:www\.)?securityfocus\.com\/bid\/([0-9]+)$"),
    ],
    "ca": [
        re.compile(
            r"^https?\:\/\/(?:www\.)?cert\.org\/advisories\/"
            r"CA\-([0-9][0-9][0-9][0-9]\-[0-9][0-9])\.html$"),
    ],
    "capec": [
        re.compile(
            r"^https?\:\/\/capec\.mitre\.org\/data\/definitions\/"
            r"([0-9]+)\.html$"),
    ],
    "cve": [
        re.compile(
            r"^https?\:\/\/cve\.mitre\.org\/cgi\-bin\/cvename\.cgi\?name\="
            r"(?:CVE\-)?([0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9][0-9]?)$"),
        re.compile(
            r"^https?\:\/\/nvd\.nist\.gov\/nvd\.cfm\?cvename\="
            r"(?:CVE\-)?([0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9][0-9]?)$"),
        re.compile(
            r"^https?\:\/\/web\.nvd\.nist\.gov\/view\/vuln\/detail\?vulnId\="
            r"(?:CVE\-)?([0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9][0-9]?)$"),
    ],
    "cwe": [
        re.compile(
        r"^https?\:\/\/cwe\.mitre\.org\/data\/definitions\/([0-9]+)\.html$"),
    ],
    "osvdb": [
        re.compile(
            r"^https?\:\/\/(?:www\.)?osvdb\.org\/show\/osvdb\/([0-9]+)$"),
    ],
    "sa": [
        re.compile(
            r"^https?\:\/\/(?:www\.)?secunia\.com\/advisories\/([0-9]+)$"),
    ],
    "sectrack": [
        re.compile(
            r"^https?\:\/\/(?:www\.)?securitytracker\.com\/id\?([0-9]+)$"),
        re.compile(
            r"^https?\:\/\/(?:www\.)?securitytracker\.com\/alerts"
            r"\/[0-9]+\/[A-Za-z]+\/([0-9]+)\.html$"),
    ],
    "vu": [
        re.compile(
            r"^https?\:\/\/(?:www\.)?kb\.cert\.org\/vuls\/id\/([0-9]+)$"),
    ],
    "xf": [
        re.compile(
            r"^https?\:\/\/xforce\.iss\.net\/xforce\/xfdb\/([0-9]+)$"),
    ],
}

# URL templates for references.
_vuln_ref_tpl = {
    "bid":      "http://www.securityfocus.com/bid/%s",
    "ca":       "https://www.cert.org/advisories/CA-%s.html",
    "capec":    "https://capec.mitre.org/data/definitions/%s.html",
    "cve":      "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-%s",
    "cwe":      "https://cwe.mitre.org/data/definitions/%s.html",
    "osvdb":    "http://osvdb.org/show/osvdb/%s",
    "sa":       "http://www.secunia.com/advisories/%s",
    "sectrack": "http://www.securitytracker.com/id?%s",
    "vu":       "https://www.kb.cert.org/vuls/id/%s",
    "xf":       "http://xforce.iss.net/xforce/xfdb/%s",
}

assert set(_vuln_id_regex.iterkeys()) == \
       set(_vuln_ref_regex.iterkeys()) == \
       set(_vuln_ref_tpl.iterkeys())


#------------------------------------------------------------------------------
def extract_vuln_ids(text):
    """
    Extract vulnerability IDs from plain text using regular expressions.

    Currently the following ID types are supported: Bugtraq ID, CAPEC, CERT,
    CVE, CWE, OSVDB, Secunia, Security Tracker and ISS X-Force.

    Example::
        >>> extract_vuln_ids(\"\"\"
        ... Here we have CVE-1234-1234 and CVE-4321-4321.
        ... We also have a CWE, namely CWE-1234.
        ... However we're only mentioning OSVDB, not using it.
        ... \"\"\")
        {'cve': ['CVE-1234-1234', 'CVE-4321-4321'], 'cwe': ['CWE-1234']}
        >>> extract_vuln_ids("There is nothing here!")
        {}

    This can be useful when instancing Vulnerability objects::
        >>> from golismero.api.data.vulnerability import UncategorizedVulnerability
        >>> description = "This vulnerability is CVE-1234-4321."
        >>> kwargs = extract_vuln_ids(description)
        >>> kwargs['description'] = description
        >>> vuln = UncategorizedVulnerability( **kwargs )
        >>> vuln.description
        'This vulnerability is CVE-1234-4321.'
        >>> vuln.cve
        ('CVE-1234-4321',)
        >>> vuln.cwe
        ()

    :param text: Plain text to search.
    :type text: str

    :returns: Map of ID type to lists of one or more strings, each string being a
        vulnerability ID of that type. Vulnerability types not found will not
        be present in the dictionary. If no vulnerability IDs were found at
        all, the dictionary will be empty.
    :rtype: dict( str -> list(str, ...) )
    """
    d = {}
    for vuln_type, vuln_re_list in _vuln_id_regex.iteritems():
        found = set()
        for vuln_re in vuln_re_list:
            found.update(vuln_re.findall(text))
        if found:
            prefix = vuln_type.upper() + "-"
            d[vuln_type] = sorted(
                prefix + vuln_id
                for vuln_id in found
            )
    return d


#------------------------------------------------------------------------------
def convert_references_to_vuln_ids(urls):
    """
    Convert reference URLs to the vulnerability IDs they point to.

    Currently the following websites are supported: CERT, MITRE, NIST, OSVDB,
    Secunia, SecurityFocus, Security Tracker and ISS X-Force.

    :param urls: List of URLs to parse. URLs not pointing to one of the
        supported websites are silently ignored.
    :type urls: list(str)

    """ # docstring completed later!
    d = {}
    for vuln_type, vuln_re_list in _vuln_ref_regex.iteritems():
        found = set()
        for vuln_re in vuln_re_list:
            for url in urls:
                found.update(vuln_re.findall(url))
        if found:
            prefix = vuln_type.upper() + "-"
            d[vuln_type] = sorted(
                prefix + vuln_id
                for vuln_id in found
            )
    return d

# Fix the docstring.
convert_references_to_vuln_ids.__doc__ += \
    extract_vuln_ids.__doc__[extract_vuln_ids.__doc__.rfind(":returns:")]


#------------------------------------------------------------------------------
def convert_vuln_ids_to_references(vuln_ids):
    """
    Convert vulnerability IDs to reference URLs.

    Currently the following ID types are supported: Bugtraq ID, CAPEC, CERT,
    CVE, CWE, OSVDB, Secunia, Security Tracker and ISS X-Force.

    :param vuln_ids: Vulnerability IDs.
    :type vuln_ids: list(str)

    :returns: Reference URLs.
    :rtype: list(str)
    """
    return [
        _vuln_ref_tpl[ vuln_type.lower() ] % vuln_id
        for vuln_type, vuln_id
        in [v.split("-", 1) for v in vuln_ids]
    ]


#------------------------------------------------------------------------------
# CPE parsing from:
# https://github.com/MarioVilas/network_tools/blob/master/cpe.py

def get_cpe_version(cpe):
    if not isinstance(cpe, basestring):
        raise TypeError("Expected string, got %r instead" % type(cpe))
    if cpe.startswith("cpe:/"):
        return "2.2"
    elif cpe.startswith("cpe:2.3:"):
        return "2.3"
    else:
        raise ValueError("Not a valid CPE name: %s" % cpe)


#------------------------------------------------------------------------------
def cpe22_unquote(s):
    if not s:
        return s
    r = []
    i = -1
    while i < len(s) - 1:
        i += 1
        c = s[i]
        if c == "\\":
            r.append("\\\\")
            continue
        if c != "%":
            r.append(c)
            continue
        h = s[ i + 1 : i + 2 ]
        if len(h) > 0 and h[0] == "%":
            r.append(c)
            i += 1
            continue
        if len(h) != 2 or \
           h[0] not in "0123456789abcdefABCDEF" or \
           h[1] not in "0123456789abcdefABCDEF":
            r.append(c)
            continue
        r.append("\\")
        r.append( chr( int(h, 16) ) )
    return "".join(r)


#------------------------------------------------------------------------------
_cpe23_split = re.compile(r"(?<!\\)\:")
def parse_cpe(cpe):
    ver = get_cpe_version(cpe)
    if ver == "2.2":
        parsed = [cpe22_unquote(x.strip()) for x in cpe[5:].split(":")]
        if len(parsed) < 11:
            parsed.extend( "*" * (11 - len(parsed)) )
    elif ver == "2.3":
        parsed = [x.strip() for x in _cpe23_split.split(cpe[8:])]
        if len(parsed) != 11:
            raise ValueError("Not a valid CPE 2.3 name: %s" % cpe)
    else:
        raise ValueError("Not a valid CPE 2.2 or 2.3 name: %s" % cpe)
    return parsed


#------------------------------------------------------------------------------
def unparse_cpe23(parsed):
    return "cpe:2.3:" + ":".join(x.replace(":", r"\:") for x in parsed)


#------------------------------------------------------------------------------
def cpe22to23(cpe):
    return unparse_cpe23( parse_cpe(cpe) )
